
# 바이너리
# 바이너리 타입은 연속된 비트를 나타낸다
# 바이너리 리터럴은 <<term, ...>>과 같이 쓴다
# 가장 단순한 단위 값은 0부터 255 사이의 숫자 하나로, 이 숫자들이 바이너리 안에 연속된 바이트로 저장된다

b = <<1, 2, 3>>
# <<1, 2, 3>>
byte_size(b)
# 3
bit_size(b)
# 24

# 각 값은 기본적으로 1바이트를 차지하지만 데이터 크기를 비트 단위로 설정할 수도 있다
# 미디어 파일이나 네트워크 패킷 같은 바이너리 포맷 데이터를 다룰 떄 유용하다

b = << 1::size(2), 1:: size(3) >> # 01 001 = 9(10진수)
# <<9::size(5)>>
byte_size(b)
# 1
bit_size(b)
# 5

# 바이너리에는 정수 외에 실수나 다른 바이너리도 저장할 수 있다
int = <<1>>
# <<1>>
float = << 2.5 :: float >>
# <<64, 4, 0, 0, 0, 0, 0, 0>>
mix = << int :: binary, float :: binary >>
# <<1, 64, 4, 0, 0, 0, 0, 0, 0>>

# 데이터에서 비트를 추출하는 예제이다
# IEEE 754 부동소수점수는 부호를 나타내는 1비트, 그 뒤의 지수를 나타내는 11비트, 가수를 나타내는 나머지 52 비트로 구성된다
# 지수 부분은 실제 지수보다 1023만큼 큰 값이며 기수는 최상위 비트를 1로 가정할 때 소수점 아래 부분이다
# 이 정의를 이용해 실수를 이루는 각 필드를 추출한 뒤 :math.pow로 거듭제곱 연산을 거쳐 조합하면 원래 숫자를 어들 수 있다
<< sign::size(1), exp::size(11), mantissa::size(52) >> = << 3.14159::float >>
# <<64, 9, 33, 249, 240, 27, 134, 110>>
(1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp - 1023) * (1 - 2 * sign)
# 3.14159
