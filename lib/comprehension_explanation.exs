
# 컴프리헨션 문
# 함수형 코드를 작성하다 보면 컬렉션에 매핑 함수를 적용하거나 항목을 필터링 하는 일이 많다
# 컴프리헨션 문은 컬렉션을 다루는 일반적인 작업에 사용 가능한 단축 문법으로, 활용하면 작업을 좀 더 쉽게 수행하고 코드의 가독성도 높일 수 있다
# 컴프리헨션 문에 담긴 아이디어는 매우 간단하다
# 컬렉션이 하나 이상 있을 때 각 컬렉션의 값으로 만들 수 있는 모든 조합을 계산한 뒤, 조건에 따라 항목을 필터링해 남은 ㄱ밧으로 새 컬렉션을 생성한다
# 문법은 겉보기에는 쉬워 보인다

# result = for 제네레이터 또는 필터... [, into: 값], do: 표현식

for x <- [1, 2, 3, 4, 5], do: x * x
# [1, 4, 9, 16, 25]
for x <- [1, 2, 3, 4, 5], x < 4, do: x * x
# [1, 4, 9]

# 제너레이터를 사용해 컬렉션에서 값을 어떻게 추출할지를 정할 수 있다
# 제네레이터의 문법은 다음과 같다

# 패턴 <- 순회 가능한 값

# 패턴에 매칭된 변수들은 컴프리헨션 문의 다른 부분에서 사용할 수 있다
# x <- [1, 2, 3] 일경우 x=1인 상태로 실행 후 x=2 상태로 실행된다
# 제네레이터가 2개이면 각각 중첩해 적용한다

# x <- [1, 2], y <- [5, 6]

# 제네레이터를 이와 같이 작성하면 x=1, y=5 -> x=1, y=6 -> x=2, y=5 ... 순서로 컴프리헨션 문의 나머지 부분을 수행하게 된다
# 이 값들을 do 블록 안에서 x, y 변수로 사용할 수 있다

for x <- [1, 2], y <- [5, 6], do: x * y
# [5, 6, 10, 12]
for x <- [1, 2], y <- [5, 6], do: {x, y}
# [{1, 5}, {1, 6}, {2, 5}, {2, 6}]

# 앞에서 받은 변수를 뒤에 있는 제네레이터에서 사용할 수도 있다
min_maxes = [{1, 4}, {2, 3}, {10, 15}]
# [{1, 4}, {2, 3}, {10, 15}]
for {min, max} <- min_maxes, n <- min..max, do: n
# [1, 2, 3, 4, 2, 3, 10, 11, 12, 13, 14, 15]

# 필터는 참 혹은 거짓을 반환하는 명제다
# 필터는 컴프리헨션의 뒷부분에서 원하는 값만을 사용하도록 문지기 역할을 한다
# 필터 조건이 거짓이면 컴프리헨션 문이 더 실해오디지 않고 다음 값으로 넘어간다

first8 = [1,2,3,4,5,6,7,8]
# [1, 2, 3, 4, 5, 6, 7, 8]
for x <- first8, y <- first8, x >= y, rem(x * y, 10) == 0, do: {x, y}
# [{5, 2}, {5, 4}, {6, 5}, {8, 5}]

# 키워드 리스트의 키와 값을 서로 바꾸는 예
reports = [ dallas: :hot, minneapolis: :cold, dc: :muggy, la: :smoggy ]
[dallas: :hot, minneapolis: :cold, dc: :muggy, la: :smoggy]
for {city, weather} <- reports, do: {weather, city}
[hot: :dallas, cold: :minneapolis, muggy: :dc, smoggy: :la]


# 비트스트링 컴프리헨션
# 연속된 비트인 비트스트링(비트스트링 + 확장인 바이너리나 문자열) 역시 2진수의 컬렉션으로 생각할 수 있다
# 따라서 비트스트링에도 컴프리헨션 문을 사용할 수 있다는 사실은 어쩌면 당연하다
# 하지만 문법은 사문 다른 모습을 볼 수 있다
for << ch <- "hello" >>, do: ch
# ~c"hello" # 아마도 'hello'
for << ch <- "hello" >>, do: <<ch>>
# ["h", "e", "l", "l", "o"]

# 제너레이터가 바이너리를 의미하는 <<>> 기호로 감싸져 있다
# 첫 번째 컴프리헨션 문에서는 do 블럭이 각 문자에 대한 정수 코드를 반환하므로, 결과로 반환되는 리스트는 [1004, 101, 108, 108, 111]이다
# IEx에서 이 리스트는 'hello' (~c"hello")로 표시된다
# 두 번째 컴프리헨션 문은 각각의 정수 코드를 문자열로 바꿔 반환하므로 결과는 한 글자짜리 문자열들의 리스트가 된다

# 제너레이터의 좌변이 패턴이므로 바이너리 패턴 매칭도 사용할 수 있다
# 다음 코드는 문자열을 이루는 각 문자의 정수 코드를 8진수로 바꾼다다
for << << b1::size(2), b2::size(3), b3::size(3) >> <- "hello">>, do: "0o#{b1}#{b2}#{b3}"
# ["0o150", "0o145", "0o154", "0o154", "0o157"]


# 컴프리헨션 문의 스코프
# 컴프리헨션 문 내에서 할당하는 변수는 해당 컴프리헨션 문 안에서만 사용할 수 있다
# 외부 변수의 값에는 영향을 미치지 않는다
name = "Dave"
# "Dave"
for name <- ["cat", "dog"], do: String.upcase(name)
# ["CAT", "DOG"]
name
# "Dave"


# 컴프리헨션 문의 반환값
# 지금까지 본 컴프리헨션 문은 리스트를 반환했으며, 리스트에 포함되는 값은 컴프리헨션 문의 각 반복에서 do 블록이 반환하는 값이었다
# into: 파라미터를 사용해 이 동작을 바꿀 수 있다
# into: 파라미터는 결과를 저장할 컬렉션을 받는다
# 예를 들어 결과를 맵으로 받을 수도 있다
for x <- ~w{cat dog}, into: %{}, do: {x, String.upcase(x)}
# %{"cat" => "CAT", "dog" => "DOG"}

# Map.new를 쓰면 의미가 더 명확하게 전달될 것이다
for x <- ~w{cat dog}, into: Map.new, do: {x, String.upcase(x)}
# %{"cat" => "CAT", "dog" => "DOG"}

# 컬렉션이 꼭 비어 있을 필요는 없다다
for x <- ~w{cat dog}, into: %{}, do: {x, String.upcase(x)}

# into: 옵션은 Collectable 프로토콜을 구현한 값을 받는다
# Collectable 프로토콜을 구현한 타입에는 리스트, 바이너리, 함수, 맵, 파일, 해시 딕셔너리, 해시 셋, IO 스트림 등이 있다
# 따라서 다음과 같은 코드도 작성할 수 있다
for x <- ~w{cat dog}, into: IO.stream(:stdio, :line), do: "<<#{x}>>\n"
# <<cat>>
# <<dog>>
# %IO.Stream{device: :standard_io, raw: false, line_or_bytes: :line}
